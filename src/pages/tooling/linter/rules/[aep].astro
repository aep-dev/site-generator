---
/**
 * Dynamic route for Protobuf Linter rule pages
 * Reads individual rule files and consolidates them by AEP number
 */

import StarlightPage from "@astrojs/starlight/components/StarlightPage.astro";
import LinterRules from "../../../../components/LinterRules.astro";
import { getCollection } from "astro:content";

export async function getStaticPaths() {
  // Get all docs entries
  const allDocs = await getCollection("docs");

  // Filter for protobuf linter rules
  const linterRules = allDocs.filter((doc) =>
    doc.id.startsWith("tooling/linter/rules/"),
  );

  // Group rules by AEP number and render their content
  const rulesByAep: Record<string, any[]> = {};
  for (const rule of linterRules) {
    // Extract AEP number from the rule's data or filename
    const pathParts = rule.id.split("/");
    const filename = pathParts[pathParts.length - 1];

    // Try to extract AEP from filename (format: {aep}-{slug} or similar)
    // Or we can read it from the entry's data if available
    const aep =
      rule.data.aep ||
      filename.split("-")[0] ||
      pathParts[pathParts.length - 2];

    if (!rulesByAep[aep]) {
      rulesByAep[aep] = [];
    }

    // Render the markdown content to HTML
    const { Content } = await rule.render();

    rulesByAep[aep].push({
      title: rule.data.title,
      aep: aep,
      Content: Content,
      filename: filename,
      slug: rule.slug,
      preamble: rule.data.preamble,
    });
  }

  // Generate paths for each AEP
  return Object.keys(rulesByAep).map((aep) => ({
    params: { aep },
    props: {
      rules: rulesByAep[aep],
      aep,
    },
  }));
}

const { rules, aep } = Astro.props;

// Extract preamble from first rule if available
const preamble = rules[0]?.preamble || "";
---

<StarlightPage
  frontmatter={{
    title: `AEP-${aep} Linter Rules`,
    tableOfContents: { minHeadingLevel: 1 },
  }}
  headings={[]}
>
  <LinterRules rules={rules} preamble={preamble} />
</StarlightPage>
