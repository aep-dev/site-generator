---
/**
 * Dynamic route for OpenAPI Linter rule pages
 * Reads directly from external linter repo and consolidates by AEP number
 */

import StarlightPage from "@astrojs/starlight/components/StarlightPage.astro";
import LinterRules from "../../../../components/LinterRules.astro";
import { assembleOpenAPILinterRules } from "../../../../../scripts/src/linter";
import { marked } from "marked";

const AEP_OPENAPI_LINTER_LOC = process.env.AEP_OPENAPI_LINTER_LOC || "";

export async function getStaticPaths() {
  const AEP_OPENAPI_LINTER_LOC = process.env.AEP_OPENAPI_LINTER_LOC || "";

  if (!AEP_OPENAPI_LINTER_LOC) {
    console.warn(
      "⚠️  AEP_OPENAPI_LINTER_LOC not set, skipping OpenAPI linter rules",
    );
    return [];
  }

  // Read rules directly from external repo
  const allRules = await assembleOpenAPILinterRules(AEP_OPENAPI_LINTER_LOC);

  // Group rules by AEP number
  const rulesByAep: Record<string, any[]> = {};
  for (const rule of allRules) {
    if (!rulesByAep[rule.aep]) {
      rulesByAep[rule.aep] = [];
    }

    // Strip frontmatter and render markdown to HTML
    const contentWithoutFrontmatter = rule.contents.replace(
      /---[\s\S]*?---/m,
      "",
    );
    const htmlContent = await marked(contentWithoutFrontmatter);

    rulesByAep[rule.aep].push({
      title: rule.title,
      aep: rule.aep,
      htmlContent: htmlContent,
      filename: rule.filename,
      slug: rule.slug,
      preamble: rule.preamble,
    });
  }

  // Generate paths for each AEP
  return Object.keys(rulesByAep).map((aep) => ({
    params: { aep },
    props: {
      rules: rulesByAep[aep],
      aep,
    },
  }));
}

const { rules, aep } = Astro.props;

// Extract preamble from first rule if available
const preamble = rules[0]?.preamble || "";
---

<StarlightPage
  frontmatter={{
    title: `AEP-${aep} Linter Rules`,
    tableOfContents: { minHeadingLevel: 1 },
  }}
  headings={[]}
>
  <LinterRules rules={rules} preamble={preamble} />
</StarlightPage>
