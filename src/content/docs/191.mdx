---
id: 191
state: approved
slug: file-and-directory-structure
created: 2024-05-04T00:00:00.000Z
placement:
  category: protobuf
title: File and directory structure

--- 
import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';
import Sample from '../../components/Sample.astro';


A consistent file and directory structure, while making minimal difference
technically, makes API surface definitions easier for users and reviewers to
read.

## Syntax

APIs defined in protocol buffers <b class="font-extrabold	text-red-700">must</b> use `proto3` syntax.

## Single package

APIs defined in protocol buffers <b class="font-extrabold	text-red-700">must</b> define each individual API in a
single package, which <b class="font-extrabold	text-red-700">must</b> end in a version component. For example:

```proto
syntax = "proto3";

package example.cloud.translation.v3;
```

APIs <b class="font-extrabold	text-red-700">must</b> reside in a directory that matches the protocol buffer
`package` directive. For example, the package above dictates that the directory
be `example/cloud/translation/v3`.

## File names

It is often useful to divide API definitions into multiple files. File names
<b class="font-extrabold	text-red-700">must</b> use `snake_case`.

APIs <b class="font-extrabold	text-yellow-700">should</b> have an obvious "entry" file, generally named after the API
itself. An API with a small number of discrete services <b class="font-extrabold text-green-700">may</b> have a separate entry
file per service.

APIs with only one file <b class="font-extrabold	text-yellow-700">should</b> use a filename corresponding to the name of
the API.

API `service` definitions and associated RPC request and response `message`
definitions <b class="font-extrabold	text-yellow-700">should</b> be defined in the same file.

Bear in mind that the file names often become module names in client libraries,
and customers use them in `import` or `use` statements. Therefore, choosing a
descriptive and language keyword-free filename does matter. For example, a file
called `import.proto` may be problematic in Python.

<Aside type="note" title="Note">
  The version <b class="font-extrabold	text-red-700">must not</b> be used as a filename, because this creates
  bizarre imports in client libraries. Filenames such as `v3.proto` or
  `v1beta1.proto` are prohibited.
</Aside>

## File layout

Individual files <b class="font-extrabold	text-yellow-700">should</b> place higher level and more important definitions
before lower level and less important definitions.

In a proto file, components <b class="font-extrabold	text-yellow-700">should</b> be in the following order, and each of
these <b class="font-extrabold	text-yellow-700">should</b> be separated by a blank line:

- Copyright and license notice (if applicable).
- The proto `syntax` statement.
- The proto `package` statement.
- Any `import` statements, in alphabetical order.
- Any file-level `option` statements.
- Any `service` definitions.
  - Methods <b class="font-extrabold	text-yellow-700">should</b> be grouped by the resource they impact, and standard
    methods <b class="font-extrabold	text-yellow-700">should</b> precede custom methods.
- Resource `message` definitions. A parent resource <b class="font-extrabold	text-red-700">must</b> be defined before
  its child resources.
- The RPC request and response `message` definitions, in the same order of the
  corresponding methods. Each request message <b class="font-extrabold	text-red-700">must</b> precede its
  corresponding response message (if any).
- Any remaining `message` definitions.
- Any top-level `enum` definitions.